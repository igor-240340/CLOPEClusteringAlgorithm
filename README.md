# CLOPEClusteringAlgorithm
Реализация алгоритма кластеризации категорийных данных CLOPE.
Оригинальная публикация - https://www.researchgate.net/publication/2589850_CLOPE_A_Fast_and_Effective_Clustering_Algorithm_for_Transactional_Data.
Дополнительную информацию можно посмотреть здесь: https://loginom.ru/blog/clope.

## Кластеризация грибов
Использован классический датасет грибов взятый здесь: https://archive.ics.uci.edu/ml/datasets/mushroom.

## Кластеризация книг
> **Замечение**: 
Кириллические названия в выходных файлах и в отчете в таблице (ссылка - в конце этого документа) могут иметь кракозябры.
Это связано с предобработкой слов и удалением определенных символов, типа запятой и т.д.
Поэтому возможна деформация кириллических символов, т.к. мы обрабатываем их побайтно и можем кое-что вырезать. Проблему эту надо будет решить, но на кластеризацию это сейчас не влияет, потому что одинаковые символы в словах мы и "корёжим" одинаково и на "близость" слов это не влияет.
Каждая строка входного файла представляет собой название книги:

```Датасет
Основы математического анализа. Том 1. Фихтенгольц.pdf
Математический анализ для школьников. Понтрягин.djvu
```

Общая идея кластеризации в том, чтобы представить название книги как транзакцию,
а каждое слово в названии - как элемент транзакции.
Ожидается, что книги, содержащие в названии близкие по смыслу слова, будут сгруппированы вместе.
Реализуется это в несколько этапов.

Удаляем список авторов из названия:
```Датасет
Основы математического анализа. Том 1.
Математический анализ для школьников.
```

Разбиваем название на слова, разделенные запятой (угловые скобки здесь для удобства восприятия знаков препинания):
```Датасет
<Основы>,<математического>,<анализа.>,<Том>,<1.>
<Математический>,<анализ>,<для>,<школьников.>
```

Очищаем слова от мусорных символов:
```Датасет
Основы,математического,анализа,Том
Математический,анализ,для,школьников
```

Очевидно, что книги имеют много общего, но проблема в том, что близкие по смыслу слова ("Математический","математического") и ("анализ","анализа") фактически разные и у нас нет перекрытия по ним.
Задача - всё-таки получить по ним перекрытие.
Была идея просто урезать эти слова, отбрасывая варьирующие части типа окончания, приставки и т.д.
Но также возникла идея применить CLOPE и для слов.

Возьмем получившиеся слова по всем названиям и каждое слово представим как транзакцию, а каждую букву - как элемент транзакции.
тогда слова ("анализ","анализа") в форме транзакций будут выглядеть так:
```Датасет
а1,н2,а3,л4,и5,з6
а1,н2,а3,л4,и5,з6,а7
```

Между транзакциями есть явное перекрытие, поэтому при подходящем параметре отталкивания они попадут в один кластер.
> **Замечение**: 
Мы смотрим на слова как на грибы, а на позиции символов - как на атрибуты грибов, а на сами символы в позициях - как на значения атрибутов.
Два совершенно неродственных слова могут быть составлены из одинаковых символов алфавита,
поэтому одинаковые символы в одинаковых позициях должны совпадать.
А те же одинаковые символы, но в разных позициях - различаться.

Теперь заменим в датасете книг каждое слово на номер кластера, в который оно попало на шаге группировки слов.
Допустим, что слова ``("Математический","математического")`` попали в кластер ``c0``, а слова ``("анализ","анализа")`` - в кластер ``c1``.
Остальные слова пускай попадут каждое в свой уникальный кластер.
Тогда список книг:
```Датасет
Основы,математического,анализа,Том
Математический,анализ,для,школьников
```
будет иметь вид:
```Датасет
c2,(c0),(c1),c3
(c0),(c1),c4,c5
```

Теперь у нас есть перекрытие по похожим словам и мы можем кластеризовать названия книг.

## Юнит тесты
Важный (как мне кажется) момент, относящийся к тому, почему без юнит-тестов в этой задаче не обойтись от слова совсем.
Как обычно, нам нужно убедиться, что наш код работает правильно. Самое первое, что приходит в голову - как минимум найти эталонный датасет и эталонную кластеризацию и сравнить при одинаковых параметрах результаты кластеризации нашей программы и эталонной.
Но вполне возможна ситуация, когда наша реализация будет некорректной, но при этом при определенных параметрах (в данном случае параметр repulsion) будет давать на выходе ожидаемое распределение по кластерам.
Допустим в эталонной (и корректной) реализации помещение транзакции в некий кластер ``C`` даёт максимальный прирост равный 10. Допустим так же, что в нашей реализации при оценке прироста качества кластера допущена ошибка и вместо 10 мы получаем 9, но тем не менее, это всё-равно оказывается максимальным приростом, поэтому транзакция в итоге окажется в правильном кластере.
Таким образом, ошибки в промежуточных оценках могут не повлиять на конечный результат - распределение по кластерам.

## Результаты
Результат получился интересный, но далеко не идеальный: многие неродственные по смыслу слова могут попасть в один кластер, например ("уровне","уравнение") и наоборот.
Посмотреть результаты при разных параметрах отталкивания для слов и названий можно здесь: https://drive.google.com/file/d/1E0t2GpN3gsUR2ey7HX2NA9YbQvFteUtm/view?usp=share_link